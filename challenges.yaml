printing:
  name: "Printing in Python"
  text: "Let's get writing our first Python program. On most programming courses, the first program you write tends to output 'Hello, World!' to the screen."
  page:
    text1: "Let's get writing our first Python program. In most programming courses, the first program you write tends to output 'Hello, World!' to the screen. Let's not break that tradition."
    question1:
      name: "question1"
      text: "For your first challenge, you will print \"Hello World!\" to the screen. In Python, this happens through the use of the word <i>print</i> with () at the end. <i>print()</i> will print anything you want to the screen.^lb^
            For example, if you wanted to put <i>\"Hello, Robot\"</i> to the screen, you would write <i>print(\"Hello, Robot\")</i>
            The first part of the solution to the challenge has been given to you. Can you figure out the other part?"
      type: "textbox"
      skeleton: "print(\"\")"
      button: "submit"
      correct: "Hello World!"
      chal_id: "0001"
variables:
  name: "Variables"
  text: "What are variables?"
  page:
    text1: "The last module was not so interesting. That's because you can't really do anything cool in any programming language without using variables. A variable is a way of sorting data in programs."
    text2: "Think of a variable like a box with a label on it. Let's say your box has a label that says \"Box A\". Then you put a whole bunch of socks in the box. If someone asks you for some socks, you can just say \"Oh, you'll want to look in Box A\" But if one day, you decide to remove all the socks and store some shoes in that box instead, you would still refer to that box as \"Box A\". The contents may have changed, but the label or the way of referring to the box remains the same."
    subheading1: "Assigning values to a variable"
    text3: "In most programming languages, to assign a value to a variable, we use the equals (=) operator. Python follows this standard, so in Python, assigning a message to our variable looks like this:"
    codeblock1: "user_text = \"Billy was here\"\nprint(user_text)"
    text4: "At any time later in the program, you can change the value of <i>user_text</i> variable again like so:"
    codeblock2: "user_text = \"Billy was here\"\nprint(user_text)\nuser_text = \"Have you seen Billy lately?\"\nprint(user_text)"
    question1:
      name: "question1"
      text: "For this question, create a variable called \"my_message\" with any message you want."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains: 
       - "="
       - "my_message"
      chal_id: ""
    subheading2: "Naming Variables"
    text6: "You can name a variable almost anything you want, but there are a few guidelines you should follow to prevent errors and to make your program easier for humans to read and understand. After all, programming languages are for people, not for computers, so we should always be thinking about the people trying to understand our code when we create variables."
    list1:
      item1: "Variable names can contain only letters, numbers, and underscores."
      item2: "You can start a variable name with a letter or an underscore, but not with a number. So variable_1 and _variable1 are both ok, but 1_variable won't work."
      item3: "Variable names are case sensitive: string and String are two different variables to a computer."
      item4: "You shouldn't use Python's built-in keywords or functions as variable names, such as print or break."
      item5: "Keep your variable names short but descriptive. A variable called this_is_a_really_long_and_pointlessly_verbose_variable_name is probably a bit long in most contexts, but likewise, a variable called a doesn't tell us much about what the variable's purpose is. Something short but also descriptive like username is much better"
    subheading3: "Variable Types"
    text7: "Every variable has its own \"type\" that decides what kind of data it can store. Some of the most common data types are:"
    list2:
      item1: "string: A series of characters (basically, text). Note that these are always surrounded by quotes. If it isn't in quotes, it isn't a string."
      item2: "integer: A whole number (could be positive or negative), e.g.: -2, -1, 0, 1, 2, 3..."
      item3: "float: A number with a decimal point, eg: 3.14, 56.99998"
      item4: "boolean: A True or False value. In some programming languages, booleans can be represented as 1 (True) and 0 (False)"
    text8: "In Python, if you're not sure what type your variable is at any given moment in your program, you can always check using the <i>type()</i> method."
    codeblock4:  "variable_1 = \"42\"\nvariable_2 = 42\nvariable_3 = 4.2\nvariable_4 = True\n\nprint(type(variable_1))\nprint(type(variable_2))\nprint(type(variable_3))\nprint(type(variable_4))\n"
    text9: "Notice the capital \"T\" in \"True\" for the boolean we have assigned as variable_4? If you don't use an uppercase \"T\", the program will error because in Python boolean values are case sensitive. You must use \"True\" or \"False\", not \"true\" or \"false\"."
strings:
  name: "Manipulating Strings"
  text: "Strings are quite simple, but you can do a lot with this type of data. A string is a series of characters, such as a word or a sentence"
  page:
    list1:
      item1: "This is a string"
      item2: "So this is also a string"
      item3: "<p>Text inside a paragraph tag</p> is also a string if we want it to be."
      item4: "lu3hd6h3309&%34-0+ is - you guessed it - a string."
    subheading1: "Strings, quotes, and escaping"
    text1: "In Python, anything inside quotes (\" \") or (' ') is a string. The ability to use either a single or double quote gives us some flexibility in Python, for instance:"
    codeblock1: "sentence_1 = \"Bob and Bill met for coffee at Starbucks.\"\nsentence_2 = \"James rushed by and accidentally knocked Bill's coffee on the floor.\"\nsentence_3 = '\"Oops, let me buy you a new coffee!\" said James.'\n\nprint(sentence_1)\nprint(sentence_2)\nprint(sentence_3)\n"
    text2: "In sentence_2 we needed to use a single quote as an apostrophe inside the string, so we wrapped the string in double quotes. In sentence_3 however, we needed to use the double quotes in the string, so we wrapped the string in single quotes. ^lb^^lb^But what would we do if we need to use both single and double quotes in our string?"
    codeblock2: "sentence_4 = '\"I spilled Bill's coffee,\" said James.'\nprint(sentence_4)\n"
    text3: "The string stored in sentence_4 uses both double quotes and single quotes as part of the string. In situations like this, we need to escape the quote within the string that's used as an apostrophe, otherwise, the program will think our string is finished after the \"l\" in"
    text4: "We escape a character by using the backward slash (\\). The backslash tells our program that the character immediately following it should be interpreted as part of the string rather than a signifier that the string has ended. ^lb^^lb^But what if we need to escape a backslash?"
    codeblock4: "sentence_5 = \"The backslash character '\\' escapes things.\"\nprint(sentence_5)"
    text5: "If we try printing out the above, it will print The backslash character '' escapes things. which isn't quite what we meant. In this case, we need another backslash. "
    text6: "Be careful when using backslashes, as it's easy to cause an error if you don't pay attention to when your backslashes need to be escaped:"
    codeblock5: "print(\"This can happen if you use a \\\")"
    subheading2: "Combining Strings"
    text8: "Python lets us combine multiple strings into one. In programming, combining strings is usually called \"concatenating\" strings"
    codeblock7: "first_name = 'Ada'\nlast_name = 'Lovelace'\nfull_name = first_name + ' ' + last_name\nprint(full_name)\n"
    text9: "The above example will output \"Ada Lovelace\" by concatenating 3 strings together: \"Ada\", the string held in the first_name variable; \"Lovelace\", the string held in the last_name variable; and a space, which we insert manually between these two strings."
    question1:
      name: "question1"
      text: "Create two variables called \"first_name\" and \"last_name\" with your first name in \"first_name\" and your last name in \"last_name\"."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains: 
       - "="
       - "last_name"
       - "first_name"
      chal_id: "0003"
    subheading3: "Adding and Stripping Whitespace"
    text10: "A \"whitespace\" refers to a type of character that doesn't print anything out, but adds some sort of spacing formatting to the output. The spacebar, tab key, and return key on your computer all create a different kind of \"whitespace\". We can add whitespace to our programs to format our output. Let's output our list of well-known agents so that each agent appears on a different line using the \\n character combination to tell the program where we want our line breaks. "
    codeblock8: "user_list = \"Bill\\nBob\\nSarah\\nMike\"\nprint(user_list)"
    question2:
      name: "question2"
      text: "Concatenate your favorite restaurant with a new line and your favorite food after the new line. Then print the variable to the screen"
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains: 
       - "="
       - "print"
      chal_id: "0004"
arithmetic:
  name: "Math"
  text: "Your favorite subject: MATH!"
  page:
    text1: "When programming, numbers are very useful to us. We use them to perform mathematical comparisons of data, track our scores in games, count things, and so on. Python treats numbers in a few different ways depending on how we use them."
    subheading1: "Integers"
    text2: "Integers are whole numbers, and don't have a decimal in them. They can be positive or negative. Just like on a calculator, you can add (+), subtract (-), multiply (*), divide (/), modulus (%), and power (**) integers in Python."
    codeblock1: "print(4 + 2)\nprint(4 - 2)\nprint(4 * 2)\nprint(4 / 2)"
    text4: "We can also use exponential operations, like 10 to the power of 4:"
    codeblock3: "print(10 ** 4)"
    text6: "We can also get the modulus, which allows us to return the remainder left over after we divide"
    codeblock5: "print(10 % 3)"
    text8: "Python allows us to specify the order we'd like to do our calculation in as well, using parenthesis to prioritize what operations we want to be done first."
    codeblock7: "print(8 + 4 * 10)\nprint((8 + 4) * 10)"
    question1:
      name: "question1"
      text: "Do the following math operations and print them to the screen:^lb^Add 1 and 1^lb^Subtract 4 from 10^lb^Multiply 2.5 by 2^lb^Divide 20 by 2^lb^Raise 2 to the power of 4^lb^And find the remainder when 50 is divided by 4"
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "2\n6\n5.0\n10.0\n16\n2"
      chal_id: "0005"
lists:
  name: "Lists"
  text: "Perfect for your grocery list"
  page:
    text1: "A list is exactly what it sounds like; a list of things stored in a particular order. It could be anything: the numbers from 1 - 10; a list of animals; all the nail polish colors you could name... for example"
    codeblock1: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros)"
    text4: "We probably won't find too much use for this list in this form: it will be more useful for us to be able to access individual items within this list using its index position within the list:"
    codeblock3: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros[0])\nprint(fav_linux_distros[1])\nprint(fav_linux_distros[2])"
    text6: "Note that when we want to access the very first item in the list, we use 0 instead of 1. This is true of most programming languages: whenever you're counting \"things\" in computer code, we always start with 0. So if we're looking for the fifth item in Mike's Linux distributions list, we'd use fav_linux_distros[4]. ^lb^^lb^What happens if we try to use an index outside the number of items in the list?"
    codeblock5: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros[7])"
    text8: "Python also gives us a shortcut way of getting the very last item in a list"
    codeblock7: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros[-1])"
    text8: "By asking for an item at the index of -1, Python will always return the last item in the list. This is helpful because we don't always know how long our list will be. This syntax extends to other negative index methods as well, letting you count backward from the end of the list rather than forward from the front. Let's try it out."
    codeblock7: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros[4])\nprint(fav_linux_distros[-2])"
    text10: "When we pluck an item from a list like this, we also get its item type. In the Linux distributions example, we get a string, which we can then manipulate as a string using our various string manipulation tools."
    codeblock9: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\ntop_fav_distro = fav_linux_distros[0]\nprint(\"Mike's favorite Linux distro is \" + top_fav_distro.upper() + \"!\")"
    text12: "We can also get a quick count of the things in our list by using the len() function"
    codeblock11: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(len(fav_linux_distros))"
    text13: "This will print out 6 which is indeed the number of items in Mike's list."
    question1:
      name: "question1"
      text: "Create a list of your favorite foods. Then save the last item concatenated with a space (\" \") and the second item in the list. Then print the variable."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains:
       - "[-1]"
       - "[1]"
       - "print("
       - "="
      chal_id: "0006"
modifyingLists:
  name: "Changing Lists"
  text: "Do you need to change something on your grocery list?"
  page:
    subheading1: Modifying a List
    text1: "What happens when Agent M wants to update the list of Linux distributions? How do we modify the list we have with new information?"
    codeblock1: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint(fav_linux_distros)\nfav_linux_distros[0] = 'Elementary'\nprint(fav_linux_distros)"
    text3: "We've created a list and saved it to the variable fav_linux_distros, with Mint as the first item in the list. Then we changed the value of the first item to Elementary."
    text4: "We can also modify a list by applying a sort to it. Mike likes things to be nice and orderly, so let's sort this list of Linux distros alphabetically."
    codeblock3: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nfav_linux_distros.sort()\nprint(fav_linux_distros)"
    text6: "And afterward, if we want to frustrate Agent M we can always reverse this list"
    codeblock5: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nfav_linux_distros.sort()\nprint(fav_linux_distros)\nfav_linux_distros.reverse()\nprint(fav_linux_distros)\n"
    question1:
      name: "question1"
      text: "Create a list with your favorite places to go. Save this list in a variable called <i>my_Favorite_Places</i>."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains:
       - "my_Favorite_Places"
       - "="
       - "["
       - "]"
      chal_id: "0007"
    subheading2: "Adding Items to Lists"
    text8: "There are a few different ways to add things to lists. Let's start by simply adding things to the end of our list."
    codeblock7: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\ntravel_bucket_list.append('New York')\ntravel_bucket_list.append('Berlin')\nprint(travel_bucket_list)"
    text8: "Here we use the append() method, which allows us to stick items onto the end of a list. When we print out our list after appending our new items, we can indeed see they've been added."
    codeblock7: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\ntravel_bucket_list.append('New York')\ntravel_bucket_list.append('Berlin')\nprint(travel_bucket_list)"
    text9: "We can even start with an empty list."
    codeblock8: "travel_bucket_list = []\ntravel_bucket_list.append('Toronto')\ntravel_bucket_list.append('Barcelona')\ntravel_bucket_list.append('Dubai')\nprint(travel_bucket_list)"
    text11: "We can also add items to an existing list at any position we want. Let's try adding a new item to the front of our travel bucket list."
    codeblock10: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\ntravel_bucket_list.insert(0, 'New York')\nprint(travel_bucket_list)"
    question2:
      name: "question2"
      text: "Use the list from the previous question and add an element. Print the list to the screen to see the results."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains:
       - ".append("
       - "="
       - "["
       - "]"
      chal_id: "0008"
    subheading3: Removing Items from Lists
    text13: "Sometimes we want to remove an item from our list, for instance, if we traveled to one of the places on our travel bucket list. Let's remove 'London' from our list. "
    codeblock12: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\nvisited = travel_bucket_list.pop()\nprint(travel_bucket_list)\nprint(visited)"
    text15: "The pop() method has taken the last item from the list and \"popped\" it off. If we wanted to remove a different item from the list, we can use pop() with an index to specify which item we want to be popped out. "
    codeblock14: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\nvisited = travel_bucket_list.pop(1)\nprint(\"I recently went to \" + visited)\nprint(travel_bucket_list)"
    text17: "What if we don't know what the position is of the thing we want to remove? Perhaps we wrote our list a long time ago, and can't remember what index position \"Hawaii\" is at. How do we remove Hawaii from our list then? Voila:"
    codeblock16: "travel_bucket_list = ['Tokyo', 'Hawaii', 'London']\ntravel_bucket_list.remove('Hawaii')\nprint(travel_bucket_list)"
    question3:
      name: "question3"
      text: "Use the list from the other two questions and remove one of the elements. Print the list to the screen to see the results."
      type: "textbox"
      skeleton: ""
      button: "submit"
      correct: "contains"
      contains:
       - ".remove("
       - "="
       - "["
       - "]"
      chal_id: "0009"
comments:
  name: "Commenting Code"
  text: "Ever forget how you coded something?"
  page:
    text1: "Code comments are a prime example of how programming languages are mostly for us humans, as they are entirely for humans alone. Code comments are pieces of information you put in the code that the computer ignores. This allows us to add notes and narration into our code without having to worry about syntax, to help make it clear to ourselves - and to others - what our program is intended to do"
    codeblock1: "# Say hello to the user\nprint(\"Hello User!\")"
    text2: "You can also add a comment inline next to the greeting like this:"
    codeblock2: "print(\"Hello User!\")# Say hello to the user"
    text3: "In the output of both the above examples, we see just the printed \"Hello User!\" statement and no indication of our commented line above it, or the commented text next to it."
    codeblock3: "Hello User!"
    text4: "Comments can be very useful to us when our code starts to get complicated, or during the \"building\" stages when we're still figuring out how to get our program to work. ^lb^^lb^If you need to add several lines of comments in a block, you can use the # notation before each new line"
    codeblock4: "# One comment line\n# Second comment line\n# Third comment line\nprint(\"Hello!\")"
    subheading: "When to Use Comments"
    list1:
      item1: "When you're building a new program^lb^As we're trying to build out code to complete a series of tasks - especially if that task is a complicated one - using comments as a way to think through the logic can be extremely helpful. We can remind ourselves what the goal is of a particularly tricky bit of code, and if we have to come back to work on our program again later, comments can help remind us what we're building, and where we got to when last we worked on it"
      item2: "Documenting your program for others^lb^Later on in this course we'll talk more about programming style and how to write clean, organized, well-structured code that shouldn't need lots of comments, but all programs benefit from an amount of inline documentation that code comments can provide. In particular, if you're working with other programmers, or if your program will need to be maintained by others in the future, code comments can help them understand what your program is doing, and the broader context for why you built the program the way you did if it's important."
      item3: "When you want to temporarily \"turn off\" parts of your code^lb^Sometimes while building or debugging, it can be helpful to quickly turn on or off smaller chunks of our code. Instead of deleting the code, or copy-pasting it somewhere else, then having to re-write it or remember where in the program it was meant to go, we can simply comment the code out inline."
    codeblock5: "print(\"Hello Bill.\")\n# print(\"Hello Susan.\")\nprint(\"Hello Mike.\")"
    text5: "In the example above, we've commented out the print(\"Hello Susan\") line, which means when we run this program, the computer will skip over that entire line and only print the \"Hello Bill\" and \"Hello Mike\" lines"
    question1:
      name: "question1"
      text: "Write some print statements with sentences inside. Then comment them out to see the effect of commenting code."
      type: "textbox"
      skeleton: "#print(\"\")"
      button: "submit"
      correct: "contains"
      contains:
       - "#"
       - "print("
      chal_id: "0010"
dictionaries:
  name: "Python Dictionaries"
  text: "Now you will be able to map words in the dictionary to their definitions and learn the dictionary!"
  page:
    text1: "A dictionary in Python is similar to a list in that it's a collection of \"things\" we can store together. Where it differs from a list is the format in which that information is stored and retrieved"
    text2: "If we wanted to represent some closed and open statistics, in a list we'd probably store it like this:"
    codeblock1: "case_stats = [21, 12, 8]\nprint('Total cases: ' + str(case_stats[0]))\nprint('Solved cases: ' + str(case_stats[1]))\nprint('Unsolved cases: ' + str(case_stats[2]))"
    text4: "This seems straightforward enough, but it's pretty fragile code. What if the list gets reordered or reversed? Or if a new stat gets added to the list? Then we'd have to update all our print functions that call on a specific index of our list for their data. ^lb^^lb^This is the kind of problem a dictionary is made for. It allows us to associate information together in helpful pairs called \"key-value pairs\", which helps in make our data more understandable as well as make it easier for us to get precisely the information we want from it without worrying about where it is in the list. ^lb^^lb^Using a dictionary, we'd represent the case statistics like this"
    codeblock3: "case_stats = {'total': 21, 'solved': 12, 'unsolved': 8}"
    text5: "Notice the difference between a list and a dictionary? The list uses square bracket notation [] whereas a dictionary uses curly bracket notation {}. The dictionary also uses a \"key: value\" notation: 'total', 'solved', and 'unsolved' are all keys, and 21, 12, and 8 are all values.^lb^^lb^The format for dictionaries is always the same: key: value. In the example above, since our key is a string, we've also wrapped our key in quotes (') while the values here are integers so they don't need quotes. Strings are always in quotes, even in dictionaries."
    text6: "You can also use an integer as the key and a string as the value: this is a completely valid dictionary as well, though perhaps not as useful for us in this case (and we'll see why later in this section). But the below example won't cause an error. Keys and values are pretty flexible parts of a dictionary."
    codeblock4: "case_stats = {21: 'total', 12: 'solved', 8: 'unsolved'}"
    text7: "So how do we get data from our dictionary into our output?"
    codeblock5: "case_stats = {'total': 21, 'solved': 12, 'unsolved': 8}\nprint('Total cases: ' + str(case_stats['total']))\nprint('Solved cases: ' + str(case_stats['solved']))\nprint('Unsolved cases: ' + str(case_stats['unsolved']))"
    text8: "Instead of using the index number to find an item in our dictionary, we tell our output what key to look for, and it will output the value it finds associated with that key.^lb^^lb^This is great because now it doesn't matter what order our items are stored in: as long as it has the same key, we'll always get the value we're looking for."
    question1:
      name: "question1"
      text: "Create a dictionary with Bill, Susan, and James's phone number and print each number and name."
      type: "textbox"
      skeleton: "case_stats = "
      button: "submit"
      correct: "contains"
      contains:
      - "{"
      - "Bill"
      - "Susan"
      - "James"
      - "print("
      chal_id: "0012"
    subheading1: "Lists inside dictionaries"
    text3: "Like with lists, we can store different types of data within a dictionary. Let's add some more information to our dictionary to describe Agent Q's case statistics and try out using a few more different data types."
    codeblock6: "case_stats = {'total': 21, 'solved': 12, 'unsolved': 8, 'month': 'June', 'percent_solved': 57.14, 'types': ['forensics', 'cryptography', 'web app']}\nprint('Month: ' + str(case_stats['month']))\nprint('Total cases: ' + str(case_stats['total'])) \nprint('Solved cases: ' + str(case_stats['solved']))\nprint('Unsolved cases: ' + str(case_stats['unsolved']))\nprint('Percent solved: ' + str(case_stats['percent_solved']) + '%')\nprint('Types of cases: ')\nprint('\t' + str(case_stats['types'][0]))\nprint('\t' + str(case_stats['types'][1])) print('\t' + str(case_stats['types'][2]))"
    text4: "Notice how we've embedded a list inside our dictionary linked to the key types? We can access the individual items in this list using the list index, which we've done here where we've called case_stats['types'][0]. This tells the computer to look for the variable called 'case_stats' which is a dictionary, and within that dictionary look for the key 'types', and within that list look for the item at index 0, which is 'forensics' in our example above."
    subheading2: "Dictionaries inside dictionaries"
    text5: "Unsurprisingly, we can also put dictionaries inside our dictionaries, like so:"
    codeblock7: "case_stats = {'month': 'June', 'stats': {'total': 21, 'solved': 12, 'unsolved': 8, 'percent_solved': 57.14}, 'types': ['forensics', 'cryptography', 'web app']}\nprint('Month: ' + str(case_stats['month']))\nprint('Total cases: ' + str(case_stats['stats']['total']))\nprint('Solved cases: ' + str(case_stats['stats']['solved']))\nprint('Unsolved cases: ' + str(case_stats['stats']['unsolved'])) print('Percent solved: ' + str(case_stats['stats']['percent_solved']) + '%')\nprint('Types of cases: ')\nprint('\t' + str(case_stats['types'][0]))\nprint('\t' + str(case_stats['types'][1]))\nprint('\t' + str(case_stats['types'][2]))"
    text6: "This code will give us the exact same output we saw in our previous example, but gives our dictionary more structure. We can start to see how powerful dictionaries can be when it comes to organizing our data. But we can also see how quickly dictionaries can get large and difficult to read. Since programming languages are for humans, let's use some formatting to make our code easier for us to read so we can see the structure of our dictionary data more clearly."
    question3:
      name: "question3"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :)\")"
      button: "submit"
      correct: ""
      chal_id: "0013"
    codeblock8: "case_stats = {\n\t\t\t\t'month': 'June',\n\t\t\t\t'stats': {\n\t\t\t\t\t\t\t'total': 21,\n\t\t\t\t\t\t\t'solved': 12,\n\t\t\t\t\t\t\t'percent_solved': 57.14\n\t\t\t\t},\n\t\t\t\t'types': ['forensics', 'cryptography', 'web app']\n\t\t\t}\nprint('Month: ' + str(case_stats['month']))\nprint('Total cases: ' + str(case_stats['stats']['total']))\nprint('Solved cases: ' + str(case_stats['stats']['solved']))\nprint('Unsolved cases: ' + str(case_stats['stats']['unsolved']))\nprint('Percent solved: ' + str(case_stats['stats']['percent_solved']) + '%')\nprint('Types of cases: ')\nprint('\t' + str(case_stats['types'][0]))\nprint('\t' + str(case_stats['types'][1]))\nprint('\t' + str(case_stats['types'][2]))"
    text7: "There we go, that's a lot easier for us to read. Any time you're building a dictionary that's more than a few key-value pairs long, it's helpful to format it like this to better understand what you're building."
    question3:
      name: "question3"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :)\")"
      button: "submit"
      correct: ""
      chal_id: "0016"
      subheading3: "Dictionaries inside lists"
    subheading4: "Modifying dictionaries"
    text9: "So what happens when Bill solves another case? Now we need to update his stats. Let's modify our dictionary"
    codeblock10: "case_stats = {'month': 'June', 'total': 21, 'solved': 12, 'unsolved': 8}\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved'])) case_stats['month'] = 'July' case_stats['total'] = 22 case_stats['solved'] = 13\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved']))"
    text10: "It's a new month, so we need to update a few pieces of information in Bill's stats. The first is, of course, the month itself. We do that by calling on the month key in case_stats with case_stats['month'] and giving it a new value, 'July': case_stats['month'] = 'July'. Then we also update 2 more pieces of information in our dictionary following the same technique: the total case number needs to go up by 1, which makes it 22, and the total number of solved cases also needs to go up by 1, which is 13. Agent Q's unsolved cases number didn't change in July, so we can leave that one as it is."
    text11: "There's another way to update the numbers here that will prove very useful to us later, because it means we don't have to do the math ourselves. We might as well let the computer do the arithmetic, and sometimes we don't actually know what the original number was. We just know we want to increase whatever it was by a specific value. In the example above, we want to increase Bill's total cases and solved cases both by 1. Let's modify our code to get the computer to do this addition for us."
    question4:
      name: "question4"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :)\")"
      button: "submit"
      correct: ""
      chal_id: "0014"
    subheading3: "Dictionaries inside lists"
    codeblock11: "case_stats = {'month': 'June', 'total': 21, 'solved': 12, 'unsolved': 8}\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved'])) case_stats['month'] = 'July' case_stats['total'] = case_stats['total'] + 1 case_stats['solved'] = case_stats['solved'] + 1\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved']))"
    text12: "This will give us exactly the same output as before, but notice how we've modified lines 9 and 10. In line 9 we're setting case_stats['total'] to itself plus 1. The computer will first retrieve the current value of case_stats['total'], which is 21, then it will add 1 to that value to get 22, and finally it will set the new value of case_stats['total'] to be 22."
    text13: "There's actually a useful short-hand way of specifying exactly this kind of 'selfincrementing' behaviour so we don't have to write out case_stats['total'] + 1, which is a bit wordy. We can use the += notation in Python to help us out here."
    codeblock12: "case_stats = {'month': 'June', 'total': 21, 'solved': 12, 'unsolved': 8}\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved'])) case_stats['month'] = 'July' case_stats['total'] += 1 case_stats['solved'] += 1\nprint('Stats for ' + case_stats['month'] + ':')\nprint('\tTotal cases: ' + str(case_stats['total']))\nprint('\tSolved cases: ' + str(case_stats['solved']))\nprint('\tUnsolved cases: ' + str(case_stats['unsolved']))"
    text14: "We've changed lines 9 and 10 to use the += notation, so now instead of the longer statement case_stats['total'] = case_stats['total'] + 1 we can use our short hand case_stats['total'] += 1 which does exactly the same thing."
    subheading5: "Adding things to dictionaries"
    text15: "Like we did with lists before, we can add things to our dictionary and even start with an empty one if we want. Let's build Bill's stats dictionary from the ground up. We'll build up our dictionary slowly and output it at different states so we can watch how it's built."
    codeblock13: "case_stats = {} case_stats['month'] = 'June'\nprint(case_stats) case_stats['total'] = 21\nprint(case_stats) case_stats['solved'] = 12\nprint(case_stats) case_stats['unsolved'] = 8\nprint(case_stats)"
    text16: "Adding a new key-value pair to our dictionary is exactly the same as updating an existing key-value pair. If the computer finds the key in the dictionary, it will update the value. If it doesn't, it will add the key and value to the front of the dictionary. And since order doesn't matter in dictionaries (because we access everything we need with the key) we don't mind what order things are in."
    subheading6: "Removing things from dictionaries"
    text17: "If you want to remove information from a dictionary, you can use del"
    codeblock14: "case_stats = {'month': 'June', 'total': 21, 'solved': 12, 'unsolved': 8}\nprint(case_stats)\ndel case_stats['unsolved']\nprint(case_stats)"
    text18: "Pretty straightforward, but remember: once you've deleted a key-value pair from a dictionary it's gone for good!"
    question5:
      name: "question5"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0015"
    subheading3: "Dictionaries inside lists" 
conditionals:
  name: "If Statements"
  text: "Now you will be able to compare two values!^lb^Does if(x == y): print(\"They are equal!\")"
  page:
    text1: "A conditional allows us to check if certain conitions are being met before we run certain parts of the program. They're ofoten referred to more casually as \"if statements\" or \"if tests\" and there's a very good reason for that: in most every programming language conditionals usually start out with an \"if\", as in \"if coffee is available, then Agent J will have a coffee.\" Let's see our simple \"if statements\" coffee example in Python."
    codeblock1: "coffee_available = True \nif coffee_available == True:\n\t print(\"Agent J will have coffee.\")"
    text2: "In this example, since we've set the <b>coffee_available</b> variable to <b>True</b>, our test passes, so the program prints out \"Agent J will have coffee.\". If we change the <b>coffee_available</b> to <b>False</b> and run the program again, nothing will be printed to the screen: since the conditions of our if statement aren't met, the code inside the if statement never runs."
    text3: "Notice here when we write our if statement, we use a double equal sign (==) instead of a single equals sign. The single one is reserved for assigning values to variables, like we did in line 1. So when we want to say X = Y in a conditional if statement, we use the double equals syntax X == Y."
    text4: "Note also the indentation in our conditional if statement: the line <b>print(\"Agent J will have coffee.\")</b> is indented from the line above it. This indentation structure is enforced by Python, and it's how Python knows which code below the if statement is <i>within</i> it and which code is <i>outside</i> it."
    codeblock2: "coffee_available = True \nif coffee_available == True: \nprint(\"Agent J will have coffee.\")"
    text5: "When we run the code without the indentation, we get an error. We can see this inside vs outside structure more clearly when we run the following code, whcih includes 2 conditional statements one after the other, as well as some printed output outside the conditionsls."
    codeblock3: "print(\"Agent J arrives at HQ in the morning.\") \ncoffee_available = True \nif coffee_available == True: \n\tprint(\"Agent J will have coffee.\") \nprint(\"In the afternoon, Agent J goes to the HQ cafe.\") \ncoffee_available = False \nif coffee_available == False: \n\tprint(\"Agent J is shcoked to discover the cafe is out of coffee!\") \nprint(\"Agent J goes home.\")"
    question1:
      name: "question1"
      text: "Write an <b>if statement</b> to test if a variable <b>youAreLearning</b> is <b>True</b>. If they are both true, then print \"Yay! You are learning!\""
      type: "textbox"
      skeleton: "youAreLearning = True"
      button: "submit"
      correct: "contains"
      contains:
       - "Yay! You are learning!"
       - "youAreLearning"
       - "if"
       - "print("
       - ")"
       - ":"
      chal_id: "0011"
conditionals2:
  name: "If Statements with Strings"
  text: "Comparing strings\nif string == \"hello\": print(\"Greetings\")"
  page:
    text1: "At their heart, all if statemetns can be evaluted as either <b>True</b> or <b>False</b>. That doesn't mean we can oly test a boolean variable, but it does mean that when the test is run it must result in either a <b>True</b> or <b>False</b> outcome."
    text2: "So we can create tests to see if 2 strings are the same, for example."
    codeblock1: "drink_available = 'coffee' \nif drink_available == 'coffee': \n\tprint(\"Agent J will have coffee.\")"
    text3: "This example checks to see if the <b>drink_available</b> variable contains a string that matches 'coffee'. If it is, the statement evaluates to <b>True</b> and the print method inside the statement is executed. If the <b>drink_available</b> variable doesn't match, everything inside the if statement is skipped over, so nothing qould be printed."
    text4: "It's important to remember that case matters to computers! We may think of 'coffee', 'Coffee', and 'COFFEE', as being all the same thing in everday language, but to a computer all these strings are different. If we don't know what kind of letter case we'll get, but we want our conditional to consider 'coffee' and 'COFFEE' as a match, we need to tweak our code slightly."
    codeblock2: "drink_available = 'COFFEE' \nif drink_available.lower() == 'coffee': \n\tprint(\"Agent J will have coffee.\")"
    text5: "Now we're transforming the value of <b>drink_available</b> to its lowercase version using the <b>lower()</b> method, which takes a string and changes any uppercase letters it finds within the string to their lowercase counterparts. Now our 2 strings match, so the statement evaluates to <b>True</b>, and our sentence will print out."
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0018"
conditionals3:
  name: "three if statements"
  text: "Conditionsals 3"
  page:
    tex1: "Now let's compare numbers. Look at this example:"
    codeblock1: "coffee_available = 4 \ncoffee_needed = 4 \nif coffee_needed == coffee_available: \n\tprint(\"There is enough coffee.\")"
    text2: "Here we're comparing the values of 2 different variables, <b>coffee_available</b> and <b>coffee_needed</b>. If they are the same, then we print the sentence <b>There is enough coffee.</b> and if there isn't, then we don't print anything. In this example, 4 and 4 match, so the statemtn evaluates as true, printing out our sentence."
    text3: "But what happens here:"
    codeblock2: "coffee_available = \"4\" \ncoffee_needed = 4 \nif coffee_needed == coffee_available: \n\tprint(\"There is enough coffee.\")"
    text4: "We've set <b>coffee_available</b> to a string value of 4, and <b>coffee_needed</b> as an integer value of 4. They're both 4 so we might expect the statemetn would evalued to <b>True</b>, but when we run this program we find it doesn't, nothing gets printed out, telling us our statement evaluated to be <b>False</b>."
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0017"
forLoops:
  name: "For Loops"
  text: "Go over your strings, arrays, dictionaries, and so much more!"
  page:
    text1: "In the previous module, we learned about lists and dictionaries, including how to add, remove, and generally modify the information in them. But so far we've done it very slowly, one item at a time. If we had a very long list we'd end up having to write a lot of repetitive code if we needed to update everything at once."
    text2: "Loops are another tool that let us manage lists and dictionaries more efficiently, with just a few lines of code. We can run the same operation on multiple items in a list."
    subheading1: "Looping through a list"
    text3: "Let's have another look at Agent M's favorite Linux distributions again"
    text4: "In order to print out each item in the list before, we had to put in a new <i>print(fav_linux_distros[0])</i>. We'd need 6 in all to print out the entire list, and if Agent M added or removed one later we'd have to manually modify our code. This is a perfect use case for a <i>for loop</i>"
    codeblock1: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nfor distro in fav_linux_distros:\n\tprint(distro)"
    text5: "Let's break our for loop down to make sure we understand how it's working.^lb^First, we create our list of Linux distributions as normal in line 1. In line 3, we define our for loop: <i>for distro in fav_linux_distros</i>:. This line is asking for an item to be pulled from the list fav_linux_distros and assigned to the variable distro for use within our for loop. On line 4, we're now inside the loop - notice the indention! - and we have asked for the item stored in the variable distro we created to be printed to the screen. The computer will go through the list, one by one, and follow the instructions we've given it for each item.^lb^It might help to think of it like this, in plain English: for every distribution in the list of Linux distributions, print the distribution's name.^lb^As you can see, loops allow us to work with lists in a powerful and very efficient way. They don't care how many items are in a list, or if you've added some or removed some. They take the list as it is, and do something over and over for each item until it runs out of items. Handy!^lb^A for loop can contain as many lines of code as you like. As with our if statements, the level of indention is how Python understands what code belongs inside the for loop and what code belongs outside the for loop."
    codeblock2: "fav_linux_distros = ['Mint', 'Debian', 'Ubuntu', 'Manjaro', 'Fedora', 'Arch']\nprint('Here is Agent M's list of favourite Linux distributions.\n') for distro in fav_linux_distros:\nprint(distro)\nprint('\t' + distro + ' is an excellent Linux distribution.')\nprint('\tWouldn't you agree that ' + distro + ' is an excellent distro?')\nprint('Those are Agent M's top ' + str(len(fav_linux_distros)) + ' Linux distributions.')"
    subheading2: "The <b>range()</b> function"
    text6: "For loops can be useful to us even if we don't have a pre-existing list to loop through. The range() function allows us to create a temporary 'list' of numbers within a specified range, which we can then loop through similar to a normal for loop.^lb^Let's take a look at a simple use of the range() function in a for loop by creating a simple counting program."
    codeblock3: "for counter in range(1,5): print(counter)"
    text7: "Hmm... that seems strange. Our range() function looks like it should count from 1 to 5, but it stops at 4. Why is this? ^lb^The range() function starts counting at the first value you specify, in this case the 1. It will run the first loop, then when it hits the end it will increment that value by 1. If that newly incremented value is the second one specified in the range() function - in this case 5 - then it will stop without running the code within the loop. ^lb^So if we want our program to count to 5, we instead need to specify a range of 1 to 6, so that our loop will run through the 5th iteration and stop when it hits 6."
    codeblock4: "for counter in range(1, 6):\n\tprint(counter)"
    text8: "The range() function is useful for doing more than just counting numbers. Agent S likes to be able to visualize progress of the forensic team's solved case statistics. Let's build a little progress bar to help Agent S see how the team is doing."
    codeblock5: "total_cases = 10\ntotal_solved = 7\ntotal_unsolved = total_cases - total_solved\nfor x in range(1,total_unsolved+1):\n\tprint('| |')\nfor x in range(1,total_solved+1):\n\tprint('|X|')"
    text9: "This code will generate us a nice little thermometer-style progress bar so Agent S can see the team's progress at a glance. Notice we've had to add 1 to our total_unsolved and total_solved variable values in our range() function, like in our previous example where we wanted to count to 5 but had to use range(1,6)."
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0016"
whileLoops:
  name: "While Loops"
  text: "Go over your strings, arrays, dictionaries <b>WHILE</b> a condition is true"
  page:
    text1: "In the previous section, we saw the for loop, which takes a collection of items and loops through them one by one, executing the same block of code on each of those items, until it runs out of items.^lb^But there's another kind of useful loop we can use: the while loop. Instead of giving the while loop a predetermined set of things to work through, we give it a condition: as long as that condition is true, the while loop will keep running.^lb^The simplest kind of while loop usually contains some kind of counter, so let's have a look at this first"
    codeblock1: "counter = 1\nwhile counter <= 3:\n\tprint(counter)\n\tcounter += 1\nprint('Loop complete!')"
    text2: "We start by creating the variable counter and assigning in the integer value of 1. Then we declare our while loop, and give it the condition while counter <= 3, which means the loop will run as long as the value of the variable counter is less than or equal to 3. Inside our while loop, we^lb^print the counter value for our reference, and then just before we leave our loop, we ask it to increment our counter variable by 1, which if you remember is the same as saying counter = counter + 1.^lb^After this, we've reached the end of our while loop, so we start again by checking to see if the condition counter <= 3 is still true. Our counter value is now 2, but since 2 is less than or equal to 3 our condition is still true so our while loop runs the code block again.^lb^Once again, at the end of the block we increment our counter again, so now it's 3, and we start again by checking if our condition is still true. It is, because 3 = 3, so the code block within the loop runs a third time, incrementing our counter to 4 at the end.^lb^Now when we check our condition for the forth time, because we've incremented our counter variable to 4, the condition counter <= 3 evaluates to False. Our while loop will only continue to run if the condition is true, so now that it's false, our while loop closes and allows the computer to move on to the next block of code outside the while loop, which is our^lb^printed statement \"Loop complete!\"."
    subheading1: "Using a flag to stop a while loop"
    text3: "The previous example is a simple one where we just want to run the while loop a certain number of times. But programs can be complicated, with lots of different branching logic. There might be many different conditions where we'd want our while loop to stop, depending on many different factors and considerations. In these situations, it's often helpful to use a flag to control your while loop.^lb^Here's a slightly contrived example, but it gives you a reasonable idea how a flag can work"
    codeblock2: "active = True\ncountdown = 3\nwhile active == True:\n\tif countdown == 0:\n\t\tcountdown = 'Go!'\n\t\tactive = False\n\telse:\n\t\tprint(countdown)\n\t\tcountdown -= 1^lb^print(countdown)"
    text4: "Let's walk through this code.^lb^First, we set and assign 2 variables: active = True, which we'll use as our flag to control the while loop, and countdown = 3 which we'll use elsewhere in our code.^lb^Next we create our while loop using while active == True which will force our while loop to keep running over and over until the active variable is set to something other than True.^lb^Inside our while loop, we have a conditional if statement. Here's where our countdown variable comes into play. If our countdown variable is equal to 0, then we'll change its value to the string 'Go!' and set the active flag to False. Otherwise we follow the else pathway, where we'll^lb^print the current value of our countdown variable first before we reassign its value to itself - 1. (This works like the += we saw in the previous example, where we incremented the value of a variable by 1. This time we're decreasing the value of a variable by 1 instead.)^lb^^lb^If the countdown variable is equal to anything except 0, the while loop will keep running over and over,^lb^printing the value of countdown then decreasing its value by 1 each time until it reaches 0. When it reaches 0, then we follow the other branch of our if statement, which sets our countdown variable to the string 'Go!' and - most importantly - sets the active variable to False. This means, when the while loop checks again active does not equal True. Our while loop has finished running, and we move outside the loop to the last bit of code that needs to execute outside the loop, which is^lb^print(countdown), outputting the final end value of our countdown variable"
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0019"
functions:
  name: "Functions"
  text: "Have you had repeating code? Functions fix that."
  page:
    text1: "Our tool box is nearly full of the basic tools we need to start building complex programs. Now that we can use conditionals and loops as well as manipulate variables, lists and dictionaries we can start to see how nearly anything is possible.^lb^Functions are another tool in our toolbox, and an important one. Functions allow us to split our code apart into smaller chunks that we can call on at any point in our program. This allows us to avoid repetition and make our code more human-readable."
    subheading1: "Defining cand Calling Functions"
    text2: "Let's start with a very simple function that says 'helo' to Agent J."
    codeblock1: "def greet_agent():\n\tprint('Hello Agent J')\n\ngreet_agent()"
    text3: "When we want to create a function we use the def keyword followed by what we want to name the function. In this case, we've named our function greet_agent(). Now we use indentation to create the body of our function: in this case, we want it to print the string \"Hello Agent J!\" when the function is called.^lb^Defining the function itself doesn't actually print the text 'Hello Agent J' to the screen. In order to execute the code inside the function, we use a function call. To call a function, we write the name of the function, followed by any necessary information in round brackets. In this case there isn't any needed additional information, so we can just call the function with greet_agent()."
    text4: "It's important to remember that a function must be defined before it can be called. If we try to do things out of order and call a function before we define it, we'll get an error."
    codeblock2: "greet_agent() \ndef greet_agent():\n\tprint('Hello Agent J!')"
    subheading2: "Function Parameters"
    text5: "We can modify this function to allow us to greet any of our agents by using a function parameter. This lets us pass information into our function at the time we call it, then have the function use that information within it when it executes."
    codeblock3: "def greet_agent(letter):\n\tprint('Hello Agent ' + letter + '!')\ngreet_agent('J')\ngreet_agent('M')\ngreet_agent('Q')\ngreet_agent('S')"
    text6: "In this example, we ^lb^define our function again, but this time we give it a parameter, letter. Think of parameters like placeholders in our function: we use them in the body of our function where we'd like to be able to control data at the time we call the function.^lb^Here we've used our placeholder parameter letter inside ourprint method, <b>print('Hello Agent ' + letter + '!')</b>.^lb^Then, having declared and created our function, we call it 4 times: once each for each of our known agents. Here's how our output look"
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0019"
    subheading3: "Return Values"
    text7: "So far, we've had our functions use the print() method to create output directly, but we may not always want this. Fortunately, instead of generating output, we can instead use return values to send information from inside our function to the line where the function was called."
    text8: "Here is a simple example of how a return value works."
    codeblock4: "def addition(x, y):\n\total = x + y\n\treturn total\n\ncalculation = addition(31, 11)\nprint(calculation)"
    text9: "In the above example, we've created a function called addition() that takes 2 parameters. It adds these parameters together and saves that value in a variable called total, and then it returns the value assigned to total. When we call the function later, passing in 31 and 11, our function dutifully does the arithmetic and returns the total - in this case 42 - which we store in the variable calculation. Finally, we print out the value stored in calculation."
    text10: "When using a return value, it's important to know that it will immediately end the function execution. For example, let's look at a variation of our code above."
    codeblock5: "def addition(x, y):\n\treturn x + y\n\tprint('You will never know I exist!')\n\nprint(addition(31, 11))"
    text11: "Here we've added a print() method to our function addition() but when we run it, it doesn't print out the line 'You will never know I exist!'. That's because we have a return value above it. The function finishes running before it gets to print('You will never know I exist!'), so this line will never execute.^lb^This can be helpful for us if a function includes an if statement or a loop, as it allows us to leave the function execution early if certain conditions are met."
    
classObject:
  name: "Classes and Objects"
  text: "While many believe classes and objects are difficult, you can do it!!"
  page:
    text1: "There is a style of programming called object-oriented that uses a construct called a class to create a model of a real-world thing and then uses that as a kind of template to create objects. When we create a class, we define how an object is constructed and behaves.^lb^For example, if we think of a real-world object like a car, there are some things all cars have in common. They all have 4 wheels, doors, an engine, and a steering wheel. There are also some ways in which all cars behave similarly: they can all move forwards and backward, turn left and right, and have horns that make a noise in an emergency. If we were programming a game that needed to have lots of different cars in it, an efficient way for us to do this would be to create a class to model all the necessary attributes of any given car, and any actions all cars should be able to take.^lb^In this section we aren't going to talk too much about the style of object-oriented programming specifically, but for now let's make sure we know how to create a class, and how to create objects from them."
    subheading1: "Creating an Agent Class"
    text2: "Let's create a very simple class that models our agents. In previous sections and modules we've learned a lot about our team of agents, so let's use some of that information to create our first class."
    codeblock1: "class Agent():\n\tname = ''\n\thot_drink = ''\n\tdef speak(self, speech):\n\t\tprint(self.name + ' says: \"' + speech + '\"')\n\n\tdef drink(self):\n\t\tprint(self.name + ' drinks a cup of ' + self.hot_drink + '.')"
    text3: "Let's go through our class line by line.^lb^We start by declaring our class and giving it a name: class Agent():. Everything that belongs to our class will be indented.^lb^Next, we create 2 variables that our class will need to work properly, but we don't assign them any values: right now, both name and hot_drink are set to be empty strings.^lb^After that we create 2 functions, speak() and drink(). In a class, functions are called methods. The only difference between a function and a method is that a method is a part of a class, which means we need to call it in a slightly different way, which we'll see in the next example.^lb^As it stands now, our Agent() class captures a model of a person who:^lb^"
    list1:
      item1: "Has a name"
      item2: "Has a hot drink preference"
      item3: "Can speak"
      item4: "Can drink their hot beverage"
    text4: "Now that we created our class, how do we use it?"
    codeblock2: "class Agent():\n\tname = ''\n\thot_drink = ''\n\tdef speak(self, speech):\n\t\tprint(self.name + ' says: \"' + speech + '\"')\n\n\tdef drink(self):\n\t\tprint(self.name + ' drinks a cup of ' + self.hot_drink + '.')\n\nagent_q = Agent()\nagent_q.name = 'Agent Q'\nagent_q.speak(\"Hi, I'm Agent Q!\")"
    text5: "After we've defined our class, once we want to start making use of it, the first thing we do is instantiate our class with agent_q = Agent(). Here, we create an object using our class as a model, and call that object agent_q. This object is a little self-contained \"thing\" that has all the attributes and methods associated to it that we defined in our class. As programmers, we would refer to this object as an instance of a class.^lb^In the next line, we take our new object agent_q and set a value for the variable name that we left as an empty string when we created the class: agent_q.name = 'Agent Q'. Notice our notation here: we use dot notation to set the value of a class variable. Variables that are accessed on objects like this are called attributes.^lb^Finally, we use one of the methods we created in our class - again, we use dot notation to access it because we are interacting with our object: agent_q.speak(\"Hi, I'm Agent Q!\").^lb^Here is the output that's generated when we execute this code:^lb^<strong>Agent Q says: \"Hi, I'm Agent Q!\"</strong>"
    subheading2: "Understanding Self"
    text6: "Notice how we refer to the attributes we created in our class? When we want to use the name attribute within one of our methods, we use self.name. Why do we do this? The self argument in the class refers to itself - the object the class creates. By calling self.name and self.hot_drink within our methods, we're telling the methods to look outside the method itself but stay within the class when trying to find the variables name and hot_drink. It's a way of determining scope: it tells Python to stay within the scope of this class.^lb^This is also why self is the first parameter of every method we define inside our class: within a class, every method needs to understand the entire class it's part of. In Python, we must declare self as the first parameter of the methods in our class, otherwise, the methods are unaware of the other methods and attributes that are also available within the class. So <strong>def speak(self, speech)</strong> has 2 parameters: self, by default because all class methods have self, and a second one, speech, which we use within just this method. Notice that when we refer to the speech parameter within the speak() method we don't use self? That's because the scope of this variable is inside the method. By not using self here, Python knows when running this code that it should only look for a variable or parameter called speech within this method.^lb^Any time you need to reference something inside the class but outside the method, you'll need self.^lb^When we call our method speak() later on our agent_q object, notice that we skip right over the first self argument and only add the second, in this case the text we want to pass as our speech argument. Python is a bit picky: it wants us to always add self as a first parameter when we declare the method, but doesn't want us to add it as an argument: it does this for us automatically every time we call the method."
    subheading3: "Object Constructors"
    text7: "Each time we created a new instance of our class Agent() above, we had to first assign its attributes. This is a little bit tedious, so let's update our class and add an object constructor. This will let us both instantiate our class and assign our key attributes all on 1 line."
    codeblock3: "class Agent():\n\tname = ''\n\thot_drink = ''\n\tdef __init__(self, name, hot_drink):\n\t\tself.name = name\n\t\tself.hot_drink = hot_drink\n\n\tdef speak(self, speech):\n\t\tprint(self.name + ' says: \"' + speech + '\"')\n\n\tdef drink(self):\n\t\tprint(self.name + ' drinks a cup of ' + self.hot_drink + '.')\n\nagent_q = Agent('Agent Q', 'decaf coffee')\nagent_m = Agent('Agent M', 'Earl Grey tea')\nagent_q.speak(\"Hi, I'm Agent Q!\")\nagent_m.speak(\"Hi, nice to meet you. I'm Agent M.\")\nagent_q.drink() agent_m.drink()"
    text8: "We've added a new method to our class, the constructor method. This method has a special name, and if we use it, it should be the very first method we define in our class. As its name \"constructor\" implies, it helps us \"construct\" the class more quickly.^lb^The constructor method uses a strange-looking name: __init__(). That's 2 underscores, followed by 'init', followed by 2 more underscores. This is to make sure this special method never conflicts with any other method you might have in your class.^lb^We give our __init__() method 3 parameters here. The first is <strong>self</strong> because <strong>self</strong> is always the first parameter of a method, and this one follows that rule. Then we also give it name and hot_drink.^lb^Inside this method, we use these parameters to set the attributes of the object: <strong>self.name = name</strong> and <strong>self.hot_drink = hot_drink</strong>. Here's how we see some of our scope at work: self.name refers to the variable outside our constructor method but inside the class, while name in this method refers to the parameter. This is why self is important: it differentiates from the name inside the method and the name inside the class.^lb^Now, when we create an object, we also pass the values we want as attributes into the object as parameters. The first thing that happens when we instantiate a class is that it is constructed, and so Python will run the <strong>__init__()</strong> method automatically every time we create a new object, using the arguments we specify at this time.^lb^The output of this new revised code is exactly the same as the output of our previous version, but we've saved some lines and created much nicer looking code."
    question1:
      name: "question1"
      text: "CHRISTIAN!!"
      type: "textbox"
      skeleton: "print(\"Christian, add a question here :) Make it with the adding and deleting glhf\")"
      button: "submit"
      correct: ""
      chal_id: "0020"